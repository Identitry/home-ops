---
# Namespace for PowerDNS
apiVersion: v1
kind: Namespace
metadata:
  name: local-dns
  labels:
    app.kubernetes.io/name: powerdns
    app.kubernetes.io/instance: powerdns
    ingress.svc.egress: allow
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/external-secrets/external-secrets/refs/heads/main/config/crds/bases/external-secrets.io_externalsecrets.yaml
# Database credentials for PowerDNS (CloudNativePG + applications)
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: es-powerdns-db-creds
  namespace: local-dns
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: infisical
  target:
    name: powerdns-db-creds
    creationPolicy: Owner
    template:
      metadata:
        labels:
          reloader.stakater.com/auto: "true"
  data:
    - secretKey: username
      remoteRef:
        key: /POWERDNS/DB_USERNAME
    - secretKey: password
      remoteRef:
        key: /POWERDNS/DB_PASSWORD
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/external-secrets/external-secrets/refs/heads/main/config/crds/bases/external-secrets.io_externalsecrets.yaml
# Application secrets, API key, bootstrap admin, and rendered pdns.conf
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: es-powerdns-app
  namespace: local-dns
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: infisical
  target:
    name: powerdns-secret
    creationPolicy: Owner
    template:
      metadata:
        labels:
          reloader.stakater.com/auto: "true"
      data:
        pdns.conf: |
          launch=gpgsql
          guardian=yes
          gpgsql-host=powerdns-db-rw.local-dns.svc
          gpgsql-dbname=powerdns
          gpgsql-user={{ .DB_USERNAME }}
          gpgsql-password={{ .DB_PASSWORD }}
          api=yes
          api-key={{ .PDNS_API_KEY }}
          webserver=yes
          webserver-port=8081
          webserver-address=0.0.0.0
          webserver-allow-from=0.0.0.0/0
          local-address=0.0.0.0
          local-port=53
        PDNS_API_KEY: "{{ .PDNS_API_KEY }}"
        ADMIN_SECRET_KEY: "{{ .ADMIN_SECRET_KEY }}"
        BOOTSTRAP_USERNAME: "{{ .BOOTSTRAP_USERNAME }}"
        BOOTSTRAP_PASSWORD: "{{ .BOOTSTRAP_PASSWORD }}"
        BOOTSTRAP_EMAIL: "{{ .BOOTSTRAP_EMAIL }}"
  data:
    - secretKey: DB_USERNAME
      remoteRef:
        key: /POWERDNS/DB_USERNAME
    - secretKey: DB_PASSWORD
      remoteRef:
        key: /POWERDNS/DB_PASSWORD
    - secretKey: PDNS_API_KEY
      remoteRef:
        key: /POWERDNS/API_KEY
    - secretKey: ADMIN_SECRET_KEY
      remoteRef:
        key: /POWERDNS/ADMIN_SECRET_KEY
    - secretKey: BOOTSTRAP_USERNAME
      remoteRef:
        key: /POWERDNS/ADMIN_BOOTSTRAP_USERNAME
    - secretKey: BOOTSTRAP_PASSWORD
      remoteRef:
        key: /POWERDNS/ADMIN_BOOTSTRAP_PASSWORD
    - secretKey: BOOTSTRAP_EMAIL
      remoteRef:
        key: /POWERDNS/ADMIN_BOOTSTRAP_EMAIL
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: powerdns-schema
  namespace: local-dns
data:
  schema.sql: |
    CREATE TABLE domains (
      id                    SERIAL PRIMARY KEY,
      name                  VARCHAR(255) NOT NULL,
      master                VARCHAR(128) DEFAULT NULL,
      last_check            INT DEFAULT NULL,
      type                  TEXT NOT NULL,
      notified_serial       BIGINT DEFAULT NULL,
      account               VARCHAR(40) DEFAULT NULL,
      options               TEXT DEFAULT NULL,
      catalog               TEXT DEFAULT NULL,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE UNIQUE INDEX name_index ON domains(name);
    CREATE INDEX catalog_idx ON domains(catalog);


    CREATE TABLE records (
      id                    BIGSERIAL PRIMARY KEY,
      domain_id             INT DEFAULT NULL,
      name                  VARCHAR(255) DEFAULT NULL,
      type                  VARCHAR(10) DEFAULT NULL,
      content               VARCHAR(65535) DEFAULT NULL,
      ttl                   INT DEFAULT NULL,
      prio                  INT DEFAULT NULL,
      disabled              BOOL DEFAULT 'f',
      ordername             VARCHAR(255),
      auth                  BOOL DEFAULT 't',
      CONSTRAINT domain_exists
      FOREIGN KEY(domain_id) REFERENCES domains(id)
      ON DELETE CASCADE,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE INDEX rec_name_index ON records(name);
    CREATE INDEX nametype_index ON records(name,type);
    CREATE INDEX domain_id ON records(domain_id);
    CREATE INDEX recordorder ON records (domain_id, ordername text_pattern_ops);


    CREATE TABLE supermasters (
      ip                    INET NOT NULL,
      nameserver            VARCHAR(255) NOT NULL,
      account               VARCHAR(40) NOT NULL,
      PRIMARY KEY(ip, nameserver)
    );


    CREATE TABLE comments (
      id                    SERIAL PRIMARY KEY,
      domain_id             INT NOT NULL,
      name                  VARCHAR(255) NOT NULL,
      type                  VARCHAR(10) NOT NULL,
      modified_at           INT NOT NULL,
      account               VARCHAR(40) DEFAULT NULL,
      comment               VARCHAR(65535) NOT NULL,
      CONSTRAINT domain_exists
      FOREIGN KEY(domain_id) REFERENCES domains(id)
      ON DELETE CASCADE,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE INDEX comments_domain_id_idx ON comments (domain_id);
    CREATE INDEX comments_name_type_idx ON comments (name, type);
    CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);


    CREATE TABLE domainmetadata (
      id                    SERIAL PRIMARY KEY,
      domain_id             INT REFERENCES domains(id) ON DELETE CASCADE,
      kind                  VARCHAR(32),
      content               TEXT
    );

    CREATE INDEX domainidmetaindex ON domainmetadata(domain_id);


    CREATE TABLE cryptokeys (
      id                    SERIAL PRIMARY KEY,
      domain_id             INT REFERENCES domains(id) ON DELETE CASCADE,
      flags                 INT NOT NULL,
      active                BOOL,
      published             BOOL DEFAULT TRUE,
      content               TEXT
    );

    CREATE INDEX domainidindex ON cryptokeys(domain_id);


    CREATE TABLE tsigkeys (
      id                    SERIAL PRIMARY KEY,
      name                  VARCHAR(255),
      algorithm             VARCHAR(50),
      secret                VARCHAR(255),
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);
  poweradmin-pgsql-db-structure.sql: |
    -- Adminer 4.8.1 PostgreSQL 14.5 (Debian 14.5-1.pgdg110+1) dump

    CREATE SEQUENCE log_users_id_seq1 INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."log_users" (
                                          "id" integer DEFAULT nextval('log_users_id_seq1') NOT NULL,
                                          "event" character varying(2048),
                                          "created_at" timestamp DEFAULT CURRENT_TIMESTAMP,
                                          "priority" integer,
                                          CONSTRAINT "log_users_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);


    CREATE SEQUENCE log_zones_id_seq1 INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."log_zones" (
                                          "id" integer DEFAULT nextval('log_zones_id_seq1') NOT NULL,
                                          "event" character varying(2048),
                                          "created_at" timestamp DEFAULT CURRENT_TIMESTAMP,
                                          "priority" integer,
                                          "zone_id" integer,
                                          CONSTRAINT "log_zones_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);


    CREATE TABLE "public"."migrations" (
                                           "version" bigint NOT NULL,
                                           "migration_name" character varying(100),
                                           "start_time" timestamp,
                                           "end_time" timestamp,
                                           "breakpoint" boolean NOT NULL DEFAULT false,
                                           CONSTRAINT "migrations_pkey" PRIMARY KEY ("version")
    ) WITH (oids = false);


    CREATE SEQUENCE perm_items_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."perm_items" (
                                           "id" integer DEFAULT nextval('perm_items_id_seq') NOT NULL,
                                           "name" character varying(64),
                                           "descr" character varying(1024),
                                           CONSTRAINT "perm_items_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);

    INSERT INTO "perm_items" ("id", "name", "descr") VALUES
                                                         (41,	'zone_master_add',	'User is allowed to add new master zones.'),
                                                         (42,	'zone_slave_add',	'User is allowed to add new slave zones.'),
                                                         (43,	'zone_content_view_own',	'User is allowed to see the content and meta data of zones he owns.'),
                                                         (44,	'zone_content_edit_own',	'User is allowed to edit the content of zones he owns.'),
                                                         (45,	'zone_meta_edit_own',	'User is allowed to edit the meta data of zones he owns.'),
                                                         (46,	'zone_content_view_others',	'User is allowed to see the content and meta data of zones he does not own.'),
                                                         (47,	'zone_content_edit_others',	'User is allowed to edit the content of zones he does not own.'),
                                                         (48,	'zone_meta_edit_others',	'User is allowed to edit the meta data of zones he does not own.'),
                                                         (49,	'search',	'User is allowed to perform searches.'),
                                                         (50,	'supermaster_view',	'User is allowed to view supermasters.'),
                                                         (51,	'supermaster_add',	'User is allowed to add new supermasters.'),
                                                         (52,	'supermaster_edit',	'User is allowed to edit supermasters.'),
                                                         (53,	'user_is_ueberuser',	'User has full access. God-like. Redeemer.'),
                                                         (54,	'user_view_others',	'User is allowed to see other users and their details.'),
                                                         (55,	'user_add_new',	'User is allowed to add new users.'),
                                                         (56,	'user_edit_own',	'User is allowed to edit their own details.'),
                                                         (57,	'user_edit_others',	'User is allowed to edit other users.'),
                                                         (58,	'user_passwd_edit_others',	'User is allowed to edit the password of other users.'),
                                                         (59,	'user_edit_templ_perm',	'User is allowed to change the permission template that is assigned to a user.'),
                                                         (60,	'templ_perm_add',	'User is allowed to add new permission templates.'),
                                                         (61,	'templ_perm_edit',	'User is allowed to edit existing permission templates.'),
                                                         (62,	'zone_content_edit_own_as_client',	'User is allowed to edit record, but not SOA and NS.'),
                                                         (63,	'zone_templ_add',	'User is allowed to add new zone templates.'),
                                                         (64,	'zone_templ_edit',	'User is allowed to edit existing zone templates.');

    CREATE SEQUENCE perm_templ_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."perm_templ" (
                                               "id" integer DEFAULT nextval('perm_templ_id_seq') NOT NULL,
                                               "name" character varying(128),
                                               "descr" character varying(1024),
                                               CONSTRAINT "perm_templ_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);

    INSERT INTO "perm_templ" ("id", "name", "descr") VALUES
        (1,	'Administrator',	'Administrator template with full rights.');

    CREATE SEQUENCE perm_templ_items_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."perm_templ_items" (
                                                 "id" integer DEFAULT nextval('perm_templ_items_id_seq') NOT NULL,
                                                 "templ_id" integer,
                                                 "perm_id" integer,
                                                 CONSTRAINT "perm_templ_items_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);

    INSERT INTO "perm_templ_items" ("id", "templ_id", "perm_id") VALUES
        (1,	1,	53);

    CREATE TABLE "public"."records_zone_templ" (
                                                   "domain_id" integer,
                                                   "record_id" integer,
                                                   "zone_templ_id" integer
    ) WITH (oids = false);


    CREATE SEQUENCE users_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."users" (
                                      "id" integer DEFAULT nextval('users_id_seq') NOT NULL,
                                      "username" character varying(64),
                                      "password" character varying(128),
                                      "fullname" character varying(255),
                                      "email" character varying(255),
                                      "description" character varying(1024),
                                      "perm_templ" integer,
                                      "active" integer,
                                      "use_ldap" integer,
                                      CONSTRAINT "users_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);

    CREATE SEQUENCE login_attempts_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."login_attempts" (
        "id" integer DEFAULT nextval('login_attempts_id_seq') NOT NULL,
        "user_id" integer NULL,
        "ip_address" character varying(45) NOT NULL,
        "timestamp" integer NOT NULL,
        "successful" boolean NOT NULL,
        CONSTRAINT "login_attempts_pkey" PRIMARY KEY ("id"),
        CONSTRAINT "fk_login_attempts_users" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    ) WITH (oids = false);

    CREATE INDEX "idx_login_attempts_user_id" ON "public"."login_attempts" USING btree ("user_id");
    CREATE INDEX "idx_login_attempts_ip_address" ON "public"."login_attempts" USING btree ("ip_address");
    CREATE INDEX "idx_login_attempts_timestamp" ON "public"."login_attempts" USING btree ("timestamp");

    CREATE SEQUENCE zone_templ_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."zone_templ" (
                                           "id" integer DEFAULT nextval('zone_templ_id_seq') NOT NULL,
                                           "name" character varying(128),
                                           "descr" character varying(1024),
                                           "owner" integer,
                                           "created_by" integer,
                                           CONSTRAINT "zone_templ_pkey" PRIMARY KEY ("id"),
                                           CONSTRAINT "fk_zone_templ_users" FOREIGN KEY ("created_by") REFERENCES "users" ("id") ON DELETE SET NULL
    ) WITH (oids = false);


    CREATE SEQUENCE zone_templ_records_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."zone_templ_records" (
                                                   "id" integer DEFAULT nextval('zone_templ_records_id_seq') NOT NULL,
                                                   "zone_templ_id" integer,
                                                   "name" character varying(255),
                                                   "type" character varying(6),
                                                   "content" character varying(2048),
                                                   "ttl" integer,
                                                   "prio" integer,
                                                   CONSTRAINT "zone_templ_records_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);


    CREATE SEQUENCE zones_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."zones" (
                                      "id" integer DEFAULT nextval('zones_id_seq') NOT NULL,
                                      "domain_id" integer,
                                      "owner" integer,
                                      "comment" character varying(1024),
                                      "zone_templ_id" integer,
                                      CONSTRAINT "zones_pkey" PRIMARY KEY ("id")
    ) WITH (oids = false);

    CREATE SEQUENCE api_keys_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."api_keys" (
        "id" integer DEFAULT nextval('api_keys_id_seq') NOT NULL,
        "name" character varying(255) NOT NULL,
        "secret_key" character varying(255) NOT NULL,
        "created_by" integer,
        "created_at" timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
        "last_used_at" timestamp,
        "disabled" boolean DEFAULT false NOT NULL,
        "expires_at" timestamp,
        CONSTRAINT "api_keys_pkey" PRIMARY KEY ("id"),
        CONSTRAINT "fk_api_keys_users" FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
    ) WITH (oids = false);

    CREATE UNIQUE INDEX "idx_api_keys_secret_key" ON "public"."api_keys" USING btree ("secret_key");
    CREATE INDEX "idx_api_keys_created_by" ON "public"."api_keys" USING btree ("created_by");
    CREATE INDEX "idx_api_keys_disabled" ON "public"."api_keys" USING btree ("disabled");

    CREATE SEQUENCE user_mfa_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1;

    CREATE TABLE "public"."user_mfa" (
        "id" integer DEFAULT nextval('user_mfa_id_seq') NOT NULL,
        "user_id" integer NOT NULL,
        "enabled" boolean DEFAULT false NOT NULL,
        "secret" character varying(255),
        "recovery_codes" text,
        "type" character varying(20) DEFAULT 'app' NOT NULL,
        "last_used_at" timestamp,
        "created_at" timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
        "updated_at" timestamp,
        "verification_data" text,
        CONSTRAINT "user_mfa_pkey" PRIMARY KEY ("id"),
        CONSTRAINT "fk_user_mfa_users" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    ) WITH (oids = false);

    CREATE UNIQUE INDEX "idx_user_mfa_user_id" ON "public"."user_mfa" USING btree ("user_id");
    CREATE INDEX "idx_user_mfa_enabled" ON "public"."user_mfa" USING btree ("enabled");

    CREATE TABLE "user_preferences" (
        "id" serial NOT NULL,
        "user_id" integer NOT NULL,
        "preference_key" character varying(100) NOT NULL,
        "preference_value" text,
        CONSTRAINT "user_preferences_pkey" PRIMARY KEY ("id"),
        CONSTRAINT "fk_user_preferences_users" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    ) WITH (oids = false);

    CREATE UNIQUE INDEX "idx_user_preferences_user_key" ON "public"."user_preferences" USING btree ("user_id", "preference_key");
    CREATE INDEX "idx_user_preferences_user_id" ON "public"."user_preferences" USING btree ("user_id");

    CREATE TABLE "zone_template_sync" (
        "id" serial NOT NULL,
        "zone_id" integer NOT NULL,
        "zone_templ_id" integer NOT NULL,
        "last_synced" timestamp,
        "template_last_modified" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
        "needs_sync" boolean NOT NULL DEFAULT false,
        "created_at" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
        "updated_at" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT "zone_template_sync_pkey" PRIMARY KEY ("id"),
        CONSTRAINT "fk_zone_template_sync_zone" FOREIGN KEY (zone_id) REFERENCES zones(id) ON DELETE CASCADE,
        CONSTRAINT "fk_zone_template_sync_templ" FOREIGN KEY (zone_templ_id) REFERENCES zone_templ(id) ON DELETE CASCADE
    ) WITH (oids = false);

    CREATE UNIQUE INDEX "idx_zone_template_unique" ON "public"."zone_template_sync" USING btree ("zone_id", "zone_templ_id");
    CREATE INDEX "idx_zone_templ_id" ON "public"."zone_template_sync" USING btree ("zone_templ_id");
    CREATE INDEX "idx_needs_sync" ON "public"."zone_template_sync" USING btree ("needs_sync");

    -- 2022-09-29 19:10:39.890321+00
    CREATE TABLE password_reset_tokens (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) NOT NULL,
        token VARCHAR(64) NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        used BOOLEAN NOT NULL DEFAULT FALSE,
        ip_address VARCHAR(45) DEFAULT NULL
    );

    CREATE INDEX idx_prt_email ON password_reset_tokens(email);
    CREATE UNIQUE INDEX idx_prt_token ON password_reset_tokens(token);
    CREATE INDEX idx_prt_expires ON password_reset_tokens(expires_at);

    CREATE TABLE user_agreements (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL,
        agreement_version VARCHAR(50) NOT NULL,
        accepted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        ip_address VARCHAR(45) DEFAULT NULL,
        user_agent TEXT DEFAULT NULL,
        CONSTRAINT fk_user_agreements_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
    );

    CREATE UNIQUE INDEX unique_user_agreement ON user_agreements(user_id, agreement_version);
    CREATE INDEX idx_user_agreements_user_id ON user_agreements(user_id);
    CREATE INDEX idx_user_agreements_version ON user_agreements(agreement_version);

# end of ConfigMap data
---
apiVersion: batch/v1
kind: Job
metadata:
  name: powerdns-apply-schemas-v2
  namespace: local-dns
spec:
  backoffLimit: 1
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: apply-schemas
          image: docker.io/library/postgres:18-alpine
          env:
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: powerdns-db-creds
                  key: username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: powerdns-db-creds
                  key: password
          command:
            - sh
            - -c
            - |
              set -e
              echo "Waiting for Postgres..."
              until pg_isready -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns; do
                sleep 2
              done
              apply() {
                file="$1"
                echo "Applying ${file}..."
                PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -f "$file"
              }
              apply /schema/schema.sql
              # Allow reruns if schema already present
              PGPASSWORD="$DB_PASSWORD" psql -v ON_ERROR_STOP=0 -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -f /schema/poweradmin-pgsql-db-structure.sql
              echo "Ensuring NS records exist for all domains..."
              PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -c "DO \$\$ DECLARE r record; BEGIN FOR r IN SELECT id, name FROM domains LOOP IF NOT EXISTS (SELECT 1 FROM records WHERE domain_id = r.id AND type = 'NS') THEN INSERT INTO records(domain_id, name, type, content, ttl, prio, disabled, auth) VALUES (r.id, r.name, 'NS', 'ns1.${DOMAIN}', 3600, 0, false, true), (r.id, r.name, 'NS', 'ns2.${DOMAIN}', 3600, 0, false, true); END IF; END LOOP; END \$\$;"
              echo "Schemas applied"
          volumeMounts:
            - name: powerdns-schema
              mountPath: /schema
      volumes:
        - name: powerdns-schema
          configMap:
            name: powerdns-schema
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/main/config/crd/bases/postgresql.cnpg.io_clusters.yaml
# CloudNativePG Cluster â€” small footprint (1Gi) for PowerDNS
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: powerdns-db
  namespace: local-dns
spec:
  instances: 2
  affinity:
    enablePodAntiAffinity: true
    topologyKey: kubernetes.io/hostname
    podAntiAffinityType: preferred

  storage:
    size: 1Gi

  bootstrap:
    initdb:
      database: powerdns
      owner: powerdns
      secret:
        name: powerdns-db-creds
      postInitApplicationSQLRefs:
        configMapRefs:
          - name: powerdns-schema
            key: schema.sql
          - name: powerdns-schema
            key: poweradmin-pgsql-db-structure.sql

  monitoring:
    enablePodMonitor: true
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/bjw-s-labs/helm-charts/main/charts/other/app-template/schemas/helmrelease-helm-v2.schema.json
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: powerdns
  namespace: local-dns
spec:
  interval: 10m
  install:
    remediation:
      retries: 3
  upgrade:
    remediation:
      retries: 3
  chartRef:
    kind: OCIRepository
    name: app-template
    namespace: cozy-fluxcd
  values:
    controllers:
      powerdns:
        replicas: 2
        annotations:
          reloader.stakater.com/match: powerdns-secret
        pod:
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            runAsGroup: 0
          labels:
            app.kubernetes.io/component: powerdns
        initContainers:
          wait-db:
            image:
              repository: docker.io/library/busybox
              tag: "1.37.0"
            command:
              - sh
              - -c
              - |
                until nc -z powerdns-db-rw.local-dns.svc 5432; do
                  echo "Waiting for Postgres...";
                  sleep 3;
                done
            securityContext:
              readOnlyRootFilesystem: true
              allowPrivilegeEscalation: false
          init-schema:
            image:
              repository: docker.io/library/postgres
              tag: "18-alpine"
            env:
              - name: DB_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: username
              - name: DB_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: password
            command:
              - sh
              - -c
              - |
                set -e
                if PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -tAc "SELECT 1 FROM pg_tables WHERE tablename='domains';" | grep -q 1; then
                  echo "PowerDNS schema already present";
                  exit 0;
                fi
                echo "Applying PowerDNS schema...";
                PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -f /schema/schema.sql
        containers:
          app:
            image:
              repository: docker.io/powerdns/pdns-auth-49
              tag: "4.9.12@sha256:b2918e4fed8f67cb6201d0ffb0d32ad8b1f0b1f7aac5eff0fc5431c4900b6b2b"
            args:
              - --config-dir=/etc/powerdns
            env:
              - name: TZ
                value: ${TZ}
            ports:
              - name: dns
                containerPort: 53
                protocol: UDP
              - name: dns-tcp
                containerPort: 53
                protocol: TCP
              - name: api
                containerPort: 8081
                protocol: TCP
            probes:
              liveness:
                enabled: true
              readiness:
                enabled: true
              startup:
                enabled: true
                spec:
                  failureThreshold: 30
                  periodSeconds: 5

      admin:
        annotations:
          reloader.stakater.com/match: powerdns-secret
        pod:
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            runAsGroup: 0
          labels:
            app.kubernetes.io/component: powerdns-admin
        initContainers:
          wait-db:
            image:
              repository: docker.io/library/busybox
              tag: "1.37.0"
            command:
              - sh
              - -c
              - |
                until nc -z powerdns-db-rw.local-dns.svc 5432; do
                  echo "Waiting for Postgres...";
                  sleep 3;
                done
            securityContext:
              readOnlyRootFilesystem: true
              allowPrivilegeEscalation: false
          init-schema:
            image:
              repository: docker.io/library/postgres
              tag: "18-alpine"
            env:
              - name: DB_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: username
              - name: DB_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: password
            command:
              - sh
              - -c
              - |
                set -e
                if PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -tAc "SELECT 1 FROM pg_tables WHERE tablename='users';" | grep -q 1; then
                  echo "PowerAdmin schema already present";
                  exit 0;
                fi
                echo "Applying PowerAdmin schema...";
                PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -f /schema/poweradmin-pgsql-db-structure.sql
        containers:
          app:
            image:
              repository: docker.io/poweradmin/poweradmin
              tag: "4.0.4@sha256:ba7e69a5f56566743a78020a63e48e009040a9bcaed1ad3d9c684a2ef6823f30"
            env:
              - name: TZ
                value: ${TZ}
              - name: DB_TYPE
                value: pgsql
              - name: DB_HOST
                value: powerdns-db-rw.local-dns.svc
              - name: DB_NAME
                value: powerdns
              - name: DB_USER
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: username
              - name: DB_PASS
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: password
              - name: DNS_NS1
                value: ns1.${DOMAIN}
              - name: DNS_NS2
                value: ns2.${DOMAIN}
              - name: DNS_HOSTMASTER
                value: hostmaster.${DOMAIN}
              - name: PA_TIMEZONE
                value: ${TZ}
              - name: PA_APP_TITLE
                value: PowerDNS Admin
              - name: PA_MAIL_ENABLED
                value: "false"
              - name: PA_API_ENABLED
                value: "false"
              - name: PA_CREATE_ADMIN
                value: "true"
              - name: PA_ADMIN_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: BOOTSTRAP_USERNAME
              - name: PA_ADMIN_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: BOOTSTRAP_PASSWORD
              - name: PA_ADMIN_EMAIL
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: BOOTSTRAP_EMAIL
              - name: PA_PDNS_DB_NAME
                value: public
              - name: PA_PDNS_API_URL
                value: http://powerdns.local-dns.svc:8081
              - name: PA_PDNS_API_KEY
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: PDNS_API_KEY
              - name: PA_SESSION_KEY
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: ADMIN_SECRET_KEY
            ports:
              - name: http
                containerPort: 80
                protocol: TCP
            probes:
              liveness:
                enabled: true
              readiness:
                enabled: true
              startup:
                enabled: true
                spec:
                  failureThreshold: 30
                  periodSeconds: 5

    defaultPodOptions:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        fsGroupChangePolicy: OnRootMismatch

    service:
      dns:
        controller: powerdns
        type: LoadBalancer
        annotations:
          metallb.io/address-pool: cozystack
        loadBalancerIP: 192.168.222.101
        externalTrafficPolicy: Local
        ports:
          dns:
            port: 53
            protocol: UDP
            targetPort: dns
          dns-tcp:
            port: 53
            protocol: TCP
            targetPort: dns-tcp
      dns2:
        controller: powerdns
        type: LoadBalancer
        annotations:
          metallb.io/address-pool: cozystack
        loadBalancerIP: 192.168.222.102
        externalTrafficPolicy: Local
        ports:
          dns:
            port: 53
            protocol: UDP
            targetPort: dns
          dns-tcp:
            port: 53
            protocol: TCP
            targetPort: dns-tcp
      api:
        controller: powerdns
        ports:
          api:
            port: 8081
            protocol: TCP
            targetPort: api
      admin:
        controller: admin
        annotations:
          external-dns.alpha.kubernetes.io/internal: "true"
          external-dns.alpha.kubernetes.io/hostname: "powerdns.${DOMAIN}"
          external-dns.alpha.kubernetes.io/target: "cluster-ingress.${DOMAIN}"
        ports:
          http:
            port: 80
            protocol: TCP
            targetPort: http

    ingress:
      admin:
        enabled: true
        className: tenant-root
        annotations:
          external-dns.alpha.kubernetes.io/target: ${CLOUDFLARE_TUNNEL_TARGET}
          external-dns.alpha.kubernetes.io/cloudflare-proxied: "true"
          external-dns.alpha.kubernetes.io/hostname: "powerdns.${DOMAIN}"
          nginx.ingress.kubernetes.io/auth-url: "http://authentik-server.authentik.svc.cozy.local/outpost.goauthentik.io/auth/nginx"
          nginx.ingress.kubernetes.io/auth-signin: "https://auth.${DOMAIN}/outpost.goauthentik.io/start?rd=$scheme://$http_host$escaped_request_uri"
          nginx.ingress.kubernetes.io/auth-response-headers: "Set-Cookie,X-authentik-username,X-authentik-email,X-authentik-name,X-authentik-uid,X-authentik-groups,X-authentik-jwt,X-authentik-meta"
          nginx.ingress.kubernetes.io/auth-snippet: |
            proxy_set_header X-Forwarded-Host $http_host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Uri $request_uri;
            proxy_set_header X-Original-Method $request_method;
          nginx.ingress.kubernetes.io/proxy-body-size: "1m"
        hosts:
          - host: powerdns.${DOMAIN}
            paths:
              - path: /
                service:
                    identifier: admin
                    port: http
        tls:
          - hosts:
              - powerdns.${DOMAIN}
            secretName: wildcard-le-tls-cert

    persistence:
      pdns-config:
        type: secret
        name: powerdns-secret
        advancedMounts:
          powerdns:
            app:
              - path: /etc/powerdns/pdns.conf
                subPath: pdns.conf
                readOnly: true
      pdns-tls:
        type: secret
        name: wildcard-le-tls-cert
        advancedMounts:
          powerdns:
            app:
              - path: /certs
                readOnly: true
      powerdns-schema:
        type: configMap
        name: powerdns-schema
        globalMounts:
          - path: /schema
            readOnly: true
---
# Allow DNS (port 53) ingress to the PowerDNS pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns-ingress
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/component: powerdns
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - ipBlock:
            cidr: 0.0.0.0/0
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
        - protocol: TCP
          port: 443
---
# Allow in-cluster access (e.g. PowerDNS-Admin) to the API port
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-from-namespace
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/component: powerdns
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: local-dns
      ports:
        - protocol: TCP
          port: 8081
---
# Allow external-dns-local namespace to reach the PowerDNS API
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-from-external-dns-local
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/component: powerdns
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: external-dns-local
      ports:
        - protocol: TCP
          port: 8081
---
# Allow ingress from tenant-root (ingress-nginx) to services in this namespace
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-ingress-from-tenant-root
  namespace: local-dns
spec:
  podSelector: {}
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: tenant-root
---
# Allow CloudNativePG operator to manage the DB pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-cnpg-operator
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      cnpg.io/cluster: powerdns-db
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: cozy-postgres-operator
      ports:
        - protocol: TCP
          port: 8000
        - protocol: TCP
          port: 5432
---
# Allow app pods in local-dns namespace to reach Postgres
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-db-from-local-dns
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      cnpg.io/cluster: powerdns-db
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: local-dns
      ports:
        - protocol: TCP
          port: 5432
