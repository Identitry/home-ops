---
# Namespace for PowerDNS
apiVersion: v1
kind: Namespace
metadata:
  name: local-dns
  labels:
    app.kubernetes.io/name: powerdns
    app.kubernetes.io/instance: powerdns
    ingress.svc.egress: allow
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/external-secrets/external-secrets/refs/heads/main/config/crds/bases/external-secrets.io_externalsecrets.yaml
# Database credentials for PowerDNS (CloudNativePG + applications)
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: es-powerdns-db-creds
  namespace: local-dns
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: infisical
  target:
    name: powerdns-db-creds
    creationPolicy: Owner
    template:
      metadata:
        labels:
          reloader.stakater.com/auto: "true"
  data:
    - secretKey: username
      remoteRef:
        key: /POWERDNS/DB_USERNAME
    - secretKey: password
      remoteRef:
        key: /POWERDNS/DB_PASSWORD
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/external-secrets/external-secrets/refs/heads/main/config/crds/bases/external-secrets.io_externalsecrets.yaml
# Application secrets, API key, bootstrap admin, and rendered pdns.conf
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: es-powerdns-app
  namespace: local-dns
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: infisical
  target:
    name: powerdns-secret
    creationPolicy: Owner
    template:
      metadata:
        labels:
          reloader.stakater.com/auto: "true"
      data:
        pdns.conf: |
          launch=gpgsql
          guardian=yes
          gpgsql-host=powerdns-db-rw.local-dns.svc
          gpgsql-dbname=powerdns
          gpgsql-user={{ .DB_USERNAME }}
          gpgsql-password={{ .DB_PASSWORD }}
          api=yes
          api-key={{ .PDNS_API_KEY }}
          webserver=yes
          webserver-port=8081
          webserver-address=0.0.0.0
          webserver-allow-from=0.0.0.0/0
          local-address=0.0.0.0
          local-port=53
        PDNS_API_KEY: "{{ .PDNS_API_KEY }}"
        ADMIN_SECRET_KEY: "{{ .ADMIN_SECRET_KEY }}"
        BOOTSTRAP_USERNAME: "{{ .BOOTSTRAP_USERNAME }}"
        BOOTSTRAP_PASSWORD: "{{ .BOOTSTRAP_PASSWORD }}"
        BOOTSTRAP_EMAIL: "{{ .BOOTSTRAP_EMAIL }}"
  data:
    - secretKey: DB_USERNAME
      remoteRef:
        key: /POWERDNS/DB_USERNAME
    - secretKey: DB_PASSWORD
      remoteRef:
        key: /POWERDNS/DB_PASSWORD
    - secretKey: PDNS_API_KEY
      remoteRef:
        key: /POWERDNS/API_KEY
    - secretKey: ADMIN_SECRET_KEY
      remoteRef:
        key: /POWERDNS/ADMIN_SECRET_KEY
    - secretKey: BOOTSTRAP_USERNAME
      remoteRef:
        key: /POWERDNS/ADMIN_BOOTSTRAP_USERNAME
    - secretKey: BOOTSTRAP_PASSWORD
      remoteRef:
        key: /POWERDNS/ADMIN_BOOTSTRAP_PASSWORD
    - secretKey: BOOTSTRAP_EMAIL
      remoteRef:
        key: /POWERDNS/ADMIN_BOOTSTRAP_EMAIL
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: powerdns-schema
  namespace: local-dns
data:
  schema.sql: |
    CREATE TABLE domains (
      id                    SERIAL PRIMARY KEY,
      name                  VARCHAR(255) NOT NULL,
      master                VARCHAR(128) DEFAULT NULL,
      last_check            INT DEFAULT NULL,
      type                  TEXT NOT NULL,
      notified_serial       BIGINT DEFAULT NULL,
      account               VARCHAR(40) DEFAULT NULL,
      options               TEXT DEFAULT NULL,
      catalog               TEXT DEFAULT NULL,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE UNIQUE INDEX name_index ON domains(name);
    CREATE INDEX catalog_idx ON domains(catalog);


    CREATE TABLE records (
      id                    BIGSERIAL PRIMARY KEY,
      domain_id             INT DEFAULT NULL,
      name                  VARCHAR(255) DEFAULT NULL,
      type                  VARCHAR(10) DEFAULT NULL,
      content               VARCHAR(65535) DEFAULT NULL,
      ttl                   INT DEFAULT NULL,
      prio                  INT DEFAULT NULL,
      disabled              BOOL DEFAULT 'f',
      ordername             VARCHAR(255),
      auth                  BOOL DEFAULT 't',
      CONSTRAINT domain_exists
      FOREIGN KEY(domain_id) REFERENCES domains(id)
      ON DELETE CASCADE,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE INDEX rec_name_index ON records(name);
    CREATE INDEX nametype_index ON records(name,type);
    CREATE INDEX domain_id ON records(domain_id);
    CREATE INDEX recordorder ON records (domain_id, ordername text_pattern_ops);


    CREATE TABLE supermasters (
      ip                    INET NOT NULL,
      nameserver            VARCHAR(255) NOT NULL,
      account               VARCHAR(40) NOT NULL,
      PRIMARY KEY(ip, nameserver)
    );


    CREATE TABLE comments (
      id                    SERIAL PRIMARY KEY,
      domain_id             INT NOT NULL,
      name                  VARCHAR(255) NOT NULL,
      type                  VARCHAR(10) NOT NULL,
      modified_at           INT NOT NULL,
      account               VARCHAR(40) DEFAULT NULL,
      comment               VARCHAR(65535) NOT NULL,
      CONSTRAINT domain_exists
      FOREIGN KEY(domain_id) REFERENCES domains(id)
      ON DELETE CASCADE,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE INDEX comments_domain_id_idx ON comments (domain_id);
    CREATE INDEX comments_name_type_idx ON comments (name, type);
    CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);


    CREATE TABLE domainmetadata (
      id                    SERIAL PRIMARY KEY,
      domain_id             INT REFERENCES domains(id) ON DELETE CASCADE,
      kind                  VARCHAR(32),
      content               TEXT
    );

    CREATE INDEX domainidmetaindex ON domainmetadata(domain_id);


    CREATE TABLE cryptokeys (
      id                    SERIAL PRIMARY KEY,
      domain_id             INT REFERENCES domains(id) ON DELETE CASCADE,
      flags                 INT NOT NULL,
      active                BOOL,
      published             BOOL DEFAULT TRUE,
      content               TEXT
    );

    CREATE INDEX domainidindex ON cryptokeys(domain_id);


    CREATE TABLE tsigkeys (
      id                    SERIAL PRIMARY KEY,
      name                  VARCHAR(255),
      algorithm             VARCHAR(50),
      secret                VARCHAR(255),
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );

    CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/main/config/crd/bases/postgresql.cnpg.io_clusters.yaml
# CloudNativePG Cluster â€” small footprint (1Gi) for PowerDNS
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: powerdns-db
  namespace: local-dns
spec:
  instances: 2
  affinity:
    enablePodAntiAffinity: true
    topologyKey: kubernetes.io/hostname
    podAntiAffinityType: preferred

  storage:
    size: 1Gi

  bootstrap:
    initdb:
      database: powerdns
      owner: powerdns
      secret:
        name: powerdns-db-creds

  monitoring:
    enablePodMonitor: true
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/bjw-s-labs/helm-charts/main/charts/other/app-template/schemas/helmrelease-helm-v2.schema.json
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: powerdns
  namespace: local-dns
spec:
  interval: 10m
  install:
    remediation:
      retries: 3
  upgrade:
    remediation:
      retries: 3
  chartRef:
    kind: OCIRepository
    name: app-template
    namespace: cozy-fluxcd
  values:
    controllers:
      powerdns:
        replicas: 2
        annotations:
          reloader.stakater.com/match: powerdns-secret
        pod:
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            runAsGroup: 0
          labels:
            app.kubernetes.io/component: powerdns
        initContainers:
          wait-db:
            image:
              repository: docker.io/library/busybox
              tag: "1.37.0"
            command:
              - sh
              - -c
              - |
                until nc -z powerdns-db-rw.local-dns.svc 5432; do
                  echo "Waiting for Postgres...";
                  sleep 3;
                done
            securityContext:
              readOnlyRootFilesystem: true
              allowPrivilegeEscalation: false
          init-schema:
            image:
              repository: docker.io/library/postgres
              tag: "16-alpine"
            env:
              - name: DB_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: username
              - name: DB_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: password
            command:
              - sh
              - -c
              - |
                set -e
                if PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -tAc "SELECT 1 FROM pg_tables WHERE tablename='domains';" | grep -q 1; then
                  echo "PowerDNS schema already present";
                  exit 0;
                fi
                echo "Applying PowerDNS schema...";
                PGPASSWORD="$DB_PASSWORD" psql -h powerdns-db-rw.local-dns.svc -U "$DB_USERNAME" -d powerdns -f /schema/schema.sql
        containers:
          app:
            image:
              repository: docker.io/powerdns/pdns-auth-49
              tag: "4.9.11@sha256:69e0e8ce5671f5f18e19c86746783ff6990555884cb9673b9845959fe05cdb46"
            args:
              - --config-dir=/etc/powerdns
            env:
              - name: TZ
                value: ${TZ}
            ports:
              - name: dns
                containerPort: 53
                protocol: UDP
              - name: dns-tcp
                containerPort: 53
                protocol: TCP
              - name: api
                containerPort: 8081
                protocol: TCP
            probes:
              liveness:
                enabled: true
              readiness:
                enabled: true
              startup:
                enabled: true
                spec:
                  failureThreshold: 30
                  periodSeconds: 5

      admin:
        annotations:
          reloader.stakater.com/match: powerdns-secret
        pod:
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            runAsGroup: 0
          labels:
            app.kubernetes.io/component: powerdns-admin
        initContainers:
          wait-db:
            image:
              repository: docker.io/library/busybox
              tag: "1.37.0"
            command:
              - sh
              - -c
              - |
                until nc -z powerdns-db-rw.local-dns.svc 5432; do
                  echo "Waiting for Postgres...";
                  sleep 3;
                done
            securityContext:
              readOnlyRootFilesystem: true
              allowPrivilegeEscalation: false
        containers:
          app:
            image:
              repository: docker.io/poweradmin/poweradmin
              tag: "4.0.4@sha256:ba7e69a5f56566743a78020a63e48e009040a9bcaed1ad3d9c684a2ef6823f30"
            env:
              - name: TZ
                value: ${TZ}
              - name: DB_TYPE
                value: pgsql
              - name: DB_HOST
                value: powerdns-db-rw.local-dns.svc
              - name: DB_NAME
                value: powerdns
              - name: DB_USER
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: username
              - name: DB_PASS
                valueFrom:
                  secretKeyRef:
                    name: powerdns-db-creds
                    key: password
              - name: DNS_NS1
                value: ns1.${DOMAIN}
              - name: DNS_NS2
                value: ns2.${DOMAIN}
              - name: DNS_HOSTMASTER
                value: hostmaster.${DOMAIN}
              - name: PA_TIMEZONE
                value: ${TZ}
              - name: PA_APP_TITLE
                value: PowerDNS Admin
              - name: PA_MAIL_ENABLED
                value: "false"
              - name: PA_API_ENABLED
                value: "false"
              - name: PA_CREATE_ADMIN
                value: "true"
              - name: PA_ADMIN_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: BOOTSTRAP_USERNAME
              - name: PA_ADMIN_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: BOOTSTRAP_PASSWORD
              - name: PA_ADMIN_EMAIL
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: BOOTSTRAP_EMAIL
              - name: PA_PDNS_DB_NAME
                value: powerdns
              - name: PA_PDNS_API_URL
                value: http://powerdns.local-dns.svc:8081
              - name: PA_PDNS_API_KEY
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: PDNS_API_KEY
              - name: PA_SESSION_KEY
                valueFrom:
                  secretKeyRef:
                    name: powerdns-secret
                    key: ADMIN_SECRET_KEY
            ports:
              - name: http
                containerPort: 80
                protocol: TCP
            probes:
              liveness:
                enabled: true
              readiness:
                enabled: true
              startup:
                enabled: true
                spec:
                  failureThreshold: 30
                  periodSeconds: 5

    defaultPodOptions:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        fsGroupChangePolicy: OnRootMismatch

    service:
      dns:
        controller: powerdns
        type: LoadBalancer
        annotations:
          metallb.io/address-pool: cozystack
          external-dns.alpha.kubernetes.io/hostname: "ns1.${DOMAIN}"
          external-dns.alpha.kubernetes.io/cloudflare-proxied: "false"
        loadBalancerIP: 192.168.222.101
        externalTrafficPolicy: Local
        ports:
          dns:
            port: 53
            protocol: UDP
            targetPort: dns
          dns-tcp:
            port: 53
            protocol: TCP
            targetPort: dns-tcp
      dns2:
        controller: powerdns
        type: LoadBalancer
        annotations:
          metallb.io/address-pool: cozystack
          external-dns.alpha.kubernetes.io/hostname: "ns2.${DOMAIN}"
          external-dns.alpha.kubernetes.io/cloudflare-proxied: "false"
        loadBalancerIP: 192.168.222.102
        externalTrafficPolicy: Local
        ports:
          dns:
            port: 53
            protocol: UDP
            targetPort: dns
          dns-tcp:
            port: 53
            protocol: TCP
            targetPort: dns-tcp
      api:
        controller: powerdns
        ports:
          api:
            port: 8081
            protocol: TCP
            targetPort: api
      admin:
        controller: admin
        ports:
          http:
            port: 80
            protocol: TCP
            targetPort: http

    ingress:
      admin:
        enabled: true
        className: tenant-root
        annotations:
          external-dns.alpha.kubernetes.io/target: ${CLOUDFLARE_TUNNEL_TARGET}
          external-dns.alpha.kubernetes.io/cloudflare-proxied: "true"
          external-dns.alpha.kubernetes.io/hostname: "powerdns.${DOMAIN}"
          nginx.ingress.kubernetes.io/auth-url: "http://authentik-server.authentik.svc.cozy.local/outpost.goauthentik.io/auth/nginx"
          nginx.ingress.kubernetes.io/auth-signin: "https://auth.${DOMAIN}/outpost.goauthentik.io/start?rd=$scheme://$http_host$escaped_request_uri"
          nginx.ingress.kubernetes.io/auth-response-headers: "Set-Cookie,X-authentik-username,X-authentik-email,X-authentik-name,X-authentik-uid,X-authentik-groups,X-authentik-jwt,X-authentik-meta"
          nginx.ingress.kubernetes.io/auth-snippet: |
            proxy_set_header X-Forwarded-Host $http_host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Uri $request_uri;
            proxy_set_header X-Original-Method $request_method;
          nginx.ingress.kubernetes.io/proxy-body-size: "1m"
        hosts:
          - host: powerdns.${DOMAIN}
            paths:
              - path: /
                service:
                    identifier: admin
                    port: http
        tls:
          - hosts:
              - powerdns.${DOMAIN}
            secretName: wildcard-le-tls-cert

    persistence:
      pdns-config:
        type: secret
        name: powerdns-secret
        advancedMounts:
          powerdns:
            app:
              - path: /etc/powerdns/pdns.conf
                subPath: pdns.conf
                readOnly: true
      pdns-tls:
        type: secret
        name: wildcard-le-tls-cert
        advancedMounts:
          powerdns:
            app:
              - path: /certs
                readOnly: true
      powerdns-schema:
        type: configMap
        name: powerdns-schema
        globalMounts:
          - path: /schema
            readOnly: true
---
# Allow DNS (port 53) ingress to the PowerDNS pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns-ingress
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/component: powerdns
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - ipBlock:
            cidr: 0.0.0.0/0
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
        - protocol: TCP
          port: 443
---
# Allow in-cluster access (e.g. PowerDNS-Admin) to the API port
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-from-namespace
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/component: powerdns
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: local-dns
      ports:
        - protocol: TCP
          port: 8081
---
# Allow ingress from tenant-root (ingress-nginx) to services in this namespace
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-ingress-from-tenant-root
  namespace: local-dns
spec:
  podSelector: {}
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: tenant-root
---
# Allow CloudNativePG operator to manage the DB pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-cnpg-operator
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      cnpg.io/cluster: powerdns-db
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: cozy-postgres-operator
      ports:
        - protocol: TCP
          port: 8000
        - protocol: TCP
          port: 5432
---
# Allow app pods in local-dns namespace to reach Postgres
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-db-from-local-dns
  namespace: local-dns
spec:
  podSelector:
    matchLabels:
      cnpg.io/cluster: powerdns-db
  policyTypes: ["Ingress"]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: local-dns
      ports:
        - protocol: TCP
          port: 5432
